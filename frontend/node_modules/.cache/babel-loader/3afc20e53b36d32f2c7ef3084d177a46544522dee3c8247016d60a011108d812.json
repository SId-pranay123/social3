{"ast":null,"code":"import { ConnectorAlreadyConnectedError } from '../errors/config.js';\n/** https://wagmi.sh/core/api/actions/connect */\nexport async function connect(config, parameters) {\n  // \"Register\" connector if not already created\n  let connector;\n  if (typeof parameters.connector === 'function') {\n    connector = config._internal.connectors.setup(parameters.connector);\n  } else connector = parameters.connector;\n  // Check if connector is already connected\n  if (connector.uid === config.state.current) throw new ConnectorAlreadyConnectedError();\n  try {\n    config.setState(x => ({\n      ...x,\n      status: 'connecting'\n    }));\n    connector.emitter.emit('message', {\n      type: 'connecting'\n    });\n    const data = await connector.connect({\n      chainId: parameters.chainId\n    });\n    const accounts = data.accounts;\n    connector.emitter.off('connect', config._internal.events.connect);\n    connector.emitter.on('change', config._internal.events.change);\n    connector.emitter.on('disconnect', config._internal.events.disconnect);\n    await config.storage?.setItem('recentConnectorId', connector.id);\n    config.setState(x => ({\n      ...x,\n      connections: new Map(x.connections).set(connector.uid, {\n        accounts,\n        chainId: data.chainId,\n        connector: connector\n      }),\n      current: connector.uid,\n      status: 'connected'\n    }));\n    return {\n      accounts,\n      chainId: data.chainId\n    };\n  } catch (error) {\n    config.setState(x => ({\n      ...x,\n      // Keep existing connector connected in case of error\n      status: x.current ? 'connected' : 'disconnected'\n    }));\n    throw error;\n  }\n}","map":{"version":3,"names":["ConnectorAlreadyConnectedError","connect","config","parameters","connector","_internal","connectors","setup","uid","state","current","setState","x","status","emitter","emit","type","data","chainId","accounts","off","events","on","change","disconnect","storage","setItem","id","connections","Map","set","error"],"sources":["/Users/siddharthpranay/Desktop/projects/Chirping/frontend/node_modules/@wagmi/core/src/actions/connect.ts"],"sourcesContent":["import type {\n  Address,\n  ResourceUnavailableRpcErrorType,\n  UserRejectedRequestErrorType,\n} from 'viem'\n\nimport type { CreateConnectorFn } from '../connectors/createConnector.js'\nimport type { Config, Connector } from '../createConfig.js'\nimport type { BaseErrorType, ErrorType } from '../errors/base.js'\nimport {\n  ConnectorAlreadyConnectedError,\n  type ConnectorAlreadyConnectedErrorType,\n} from '../errors/config.js'\nimport type { ChainIdParameter } from '../types/properties.js'\nimport type { Compute } from '../types/utils.js'\n\nexport type ConnectParameters<config extends Config = Config> = Compute<\n  ChainIdParameter<config> & {\n    connector: Connector | CreateConnectorFn\n  }\n>\n\nexport type ConnectReturnType<config extends Config = Config> = {\n  accounts: readonly [Address, ...Address[]]\n  chainId:\n    | config['chains'][number]['id']\n    | (number extends config['chains'][number]['id'] ? number : number & {})\n}\n\nexport type ConnectErrorType =\n  | ConnectorAlreadyConnectedErrorType\n  // connector.connect()\n  | UserRejectedRequestErrorType\n  | ResourceUnavailableRpcErrorType\n  // base\n  | BaseErrorType\n  | ErrorType\n\n/** https://wagmi.sh/core/api/actions/connect */\nexport async function connect<config extends Config>(\n  config: config,\n  parameters: ConnectParameters<config>,\n): Promise<ConnectReturnType<config>> {\n  // \"Register\" connector if not already created\n  let connector: Connector\n  if (typeof parameters.connector === 'function') {\n    connector = config._internal.connectors.setup(parameters.connector)\n  } else connector = parameters.connector\n\n  // Check if connector is already connected\n  if (connector.uid === config.state.current)\n    throw new ConnectorAlreadyConnectedError()\n\n  try {\n    config.setState((x) => ({ ...x, status: 'connecting' }))\n    connector.emitter.emit('message', { type: 'connecting' })\n\n    const data = await connector.connect({ chainId: parameters.chainId })\n    const accounts = data.accounts as readonly [Address, ...Address[]]\n\n    connector.emitter.off('connect', config._internal.events.connect)\n    connector.emitter.on('change', config._internal.events.change)\n    connector.emitter.on('disconnect', config._internal.events.disconnect)\n\n    await config.storage?.setItem('recentConnectorId', connector.id)\n    config.setState((x) => ({\n      ...x,\n      connections: new Map(x.connections).set(connector.uid, {\n        accounts,\n        chainId: data.chainId,\n        connector: connector,\n      }),\n      current: connector.uid,\n      status: 'connected',\n    }))\n\n    return { accounts, chainId: data.chainId }\n  } catch (error) {\n    config.setState((x) => ({\n      ...x,\n      // Keep existing connector connected in case of error\n      status: x.current ? 'connected' : 'disconnected',\n    }))\n    throw error\n  }\n}\n"],"mappings":"AASA,SACEA,8BAA8B,QAEzB,qBAAqB;AA0B5B;AACA,OAAO,eAAeC,OAAOA,CAC3BC,MAAc,EACdC,UAAqC;EAErC;EACA,IAAIC,SAAoB;EACxB,IAAI,OAAOD,UAAU,CAACC,SAAS,KAAK,UAAU,EAAE;IAC9CA,SAAS,GAAGF,MAAM,CAACG,SAAS,CAACC,UAAU,CAACC,KAAK,CAACJ,UAAU,CAACC,SAAS,CAAC;EACrE,CAAC,MAAMA,SAAS,GAAGD,UAAU,CAACC,SAAS;EAEvC;EACA,IAAIA,SAAS,CAACI,GAAG,KAAKN,MAAM,CAACO,KAAK,CAACC,OAAO,EACxC,MAAM,IAAIV,8BAA8B,EAAE;EAE5C,IAAI;IACFE,MAAM,CAACS,QAAQ,CAAEC,CAAC,KAAM;MAAE,GAAGA,CAAC;MAAEC,MAAM,EAAE;IAAY,CAAE,CAAC,CAAC;IACxDT,SAAS,CAACU,OAAO,CAACC,IAAI,CAAC,SAAS,EAAE;MAAEC,IAAI,EAAE;IAAY,CAAE,CAAC;IAEzD,MAAMC,IAAI,GAAG,MAAMb,SAAS,CAACH,OAAO,CAAC;MAAEiB,OAAO,EAAEf,UAAU,CAACe;IAAO,CAAE,CAAC;IACrE,MAAMC,QAAQ,GAAGF,IAAI,CAACE,QAA4C;IAElEf,SAAS,CAACU,OAAO,CAACM,GAAG,CAAC,SAAS,EAAElB,MAAM,CAACG,SAAS,CAACgB,MAAM,CAACpB,OAAO,CAAC;IACjEG,SAAS,CAACU,OAAO,CAACQ,EAAE,CAAC,QAAQ,EAAEpB,MAAM,CAACG,SAAS,CAACgB,MAAM,CAACE,MAAM,CAAC;IAC9DnB,SAAS,CAACU,OAAO,CAACQ,EAAE,CAAC,YAAY,EAAEpB,MAAM,CAACG,SAAS,CAACgB,MAAM,CAACG,UAAU,CAAC;IAEtE,MAAMtB,MAAM,CAACuB,OAAO,EAAEC,OAAO,CAAC,mBAAmB,EAAEtB,SAAS,CAACuB,EAAE,CAAC;IAChEzB,MAAM,CAACS,QAAQ,CAAEC,CAAC,KAAM;MACtB,GAAGA,CAAC;MACJgB,WAAW,EAAE,IAAIC,GAAG,CAACjB,CAAC,CAACgB,WAAW,CAAC,CAACE,GAAG,CAAC1B,SAAS,CAACI,GAAG,EAAE;QACrDW,QAAQ;QACRD,OAAO,EAAED,IAAI,CAACC,OAAO;QACrBd,SAAS,EAAEA;OACZ,CAAC;MACFM,OAAO,EAAEN,SAAS,CAACI,GAAG;MACtBK,MAAM,EAAE;KACT,CAAC,CAAC;IAEH,OAAO;MAAEM,QAAQ;MAAED,OAAO,EAAED,IAAI,CAACC;IAAO,CAAE;EAC5C,CAAC,CAAC,OAAOa,KAAK,EAAE;IACd7B,MAAM,CAACS,QAAQ,CAAEC,CAAC,KAAM;MACtB,GAAGA,CAAC;MACJ;MACAC,MAAM,EAAED,CAAC,CAACF,OAAO,GAAG,WAAW,GAAG;KACnC,CAAC,CAAC;IACH,MAAMqB,KAAK;EACb;AACF","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}