{"ast":null,"code":"import { ProviderNotFoundError, createConnector } from '@wagmi/core';\nimport { getAddress, withTimeout } from 'viem';\nsafe.type = 'safe';\nexport function safe() {\n  let parameters = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n  const {\n    shimDisconnect = false\n  } = parameters;\n  let provider_;\n  let disconnect;\n  return createConnector(config => ({\n    id: 'safe',\n    name: 'Safe',\n    type: safe.type,\n    async connect() {\n      const provider = await this.getProvider();\n      if (!provider) throw new ProviderNotFoundError();\n      const accounts = await this.getAccounts();\n      const chainId = await this.getChainId();\n      if (!disconnect) {\n        disconnect = this.onDisconnect.bind(this);\n        provider.on('disconnect', disconnect);\n      }\n      // Remove disconnected shim if it exists\n      if (shimDisconnect) await config.storage?.removeItem('safe.disconnected');\n      return {\n        accounts,\n        chainId\n      };\n    },\n    async disconnect() {\n      const provider = await this.getProvider();\n      if (!provider) throw new ProviderNotFoundError();\n      if (disconnect) {\n        provider.removeListener('disconnect', disconnect);\n        disconnect = undefined;\n      }\n      // Add shim signalling connector is disconnected\n      if (shimDisconnect) await config.storage?.setItem('safe.disconnected', true);\n    },\n    async getAccounts() {\n      const provider = await this.getProvider();\n      if (!provider) throw new ProviderNotFoundError();\n      return (await provider.request({\n        method: 'eth_accounts'\n      })).map(getAddress);\n    },\n    async getProvider() {\n      // Only allowed in iframe context\n      const isIframe = typeof window !== 'undefined' && window?.parent !== window;\n      if (!isIframe) return;\n      if (!provider_) {\n        const {\n          default: SDK\n        } = await import('@safe-global/safe-apps-sdk');\n        const sdk = new SDK(parameters);\n        // `getInfo` hangs when not used in Safe App iFrame\n        // https://github.com/safe-global/safe-apps-sdk/issues/263#issuecomment-1029835840\n        const safe = await withTimeout(() => sdk.safe.getInfo(), {\n          timeout: parameters.unstable_getInfoTimeout ?? 10\n        });\n        if (!safe) throw new Error('Could not load Safe information');\n        const {\n          SafeAppProvider\n        } = await import('@safe-global/safe-apps-provider');\n        provider_ = new SafeAppProvider(safe, sdk);\n      }\n      return provider_;\n    },\n    async getChainId() {\n      const provider = await this.getProvider();\n      if (!provider) throw new ProviderNotFoundError();\n      return Number(provider.chainId);\n    },\n    async isAuthorized() {\n      try {\n        const isDisconnected = shimDisconnect && (\n        // If shim exists in storage, connector is disconnected\n        await config.storage?.getItem('safe.disconnected'));\n        if (isDisconnected) return false;\n        const accounts = await this.getAccounts();\n        return !!accounts.length;\n      } catch {\n        return false;\n      }\n    },\n    onAccountsChanged() {\n      // Not relevant for Safe because changing account requires app reload.\n    },\n    onChainChanged() {\n      // Not relevant for Safe because Safe smart contract wallets only exist on single chain.\n    },\n    onDisconnect() {\n      config.emitter.emit('disconnect');\n    }\n  }));\n}","map":{"version":3,"names":["ProviderNotFoundError","createConnector","getAddress","withTimeout","safe","type","parameters","arguments","length","undefined","shimDisconnect","provider_","disconnect","config","id","name","connect","provider","getProvider","accounts","getAccounts","chainId","getChainId","onDisconnect","bind","on","storage","removeItem","removeListener","setItem","request","method","map","isIframe","window","parent","default","SDK","sdk","getInfo","timeout","unstable_getInfoTimeout","Error","SafeAppProvider","Number","isAuthorized","isDisconnected","getItem","onAccountsChanged","onChainChanged","emitter","emit"],"sources":["/Users/siddharthpranay/Desktop/projects/Chirping/frontend/node_modules/@wagmi/connectors/src/safe.ts"],"sourcesContent":["import type { SafeAppProvider } from '@safe-global/safe-apps-provider'\nimport type { Opts } from '@safe-global/safe-apps-sdk'\nimport {\n  type Connector,\n  ProviderNotFoundError,\n  createConnector,\n} from '@wagmi/core'\nimport type { Compute } from '@wagmi/core/internal'\nimport { getAddress, withTimeout } from 'viem'\n\nexport type SafeParameters = Compute<\n  Opts & {\n    /**\n     * Connector automatically connects when used as Safe App.\n     *\n     * This flag simulates the disconnect behavior by keeping track of connection status in storage\n     * and only autoconnecting when previously connected by user action (e.g. explicitly choosing to connect).\n     *\n     * @default false\n     */\n    shimDisconnect?: boolean | undefined\n    /**\n     * Timeout in milliseconds for `getInfo` (from the Safe SDK) to resolve.\n     *\n     * `getInfo` does not resolve when not used in Safe App iFrame. This allows the connector to force a timeout.\n     * @default 10\n     */\n    unstable_getInfoTimeout?: number | undefined\n  }\n>\n\nsafe.type = 'safe' as const\nexport function safe(parameters: SafeParameters = {}) {\n  const { shimDisconnect = false } = parameters\n\n  type Provider = SafeAppProvider | undefined\n  type Properties = Record<string, unknown>\n  type StorageItem = { 'safe.disconnected': true }\n\n  let provider_: Provider | undefined\n\n  let disconnect: Connector['onDisconnect'] | undefined\n\n  return createConnector<Provider, Properties, StorageItem>((config) => ({\n    id: 'safe',\n    name: 'Safe',\n    type: safe.type,\n    async connect() {\n      const provider = await this.getProvider()\n      if (!provider) throw new ProviderNotFoundError()\n\n      const accounts = await this.getAccounts()\n      const chainId = await this.getChainId()\n\n      if (!disconnect) {\n        disconnect = this.onDisconnect.bind(this)\n        provider.on('disconnect', disconnect)\n      }\n\n      // Remove disconnected shim if it exists\n      if (shimDisconnect) await config.storage?.removeItem('safe.disconnected')\n\n      return { accounts, chainId }\n    },\n    async disconnect() {\n      const provider = await this.getProvider()\n      if (!provider) throw new ProviderNotFoundError()\n\n      if (disconnect) {\n        provider.removeListener('disconnect', disconnect)\n        disconnect = undefined\n      }\n\n      // Add shim signalling connector is disconnected\n      if (shimDisconnect)\n        await config.storage?.setItem('safe.disconnected', true)\n    },\n    async getAccounts() {\n      const provider = await this.getProvider()\n      if (!provider) throw new ProviderNotFoundError()\n      return (await provider.request({ method: 'eth_accounts' })).map(\n        getAddress,\n      )\n    },\n    async getProvider() {\n      // Only allowed in iframe context\n      const isIframe =\n        typeof window !== 'undefined' && window?.parent !== window\n      if (!isIframe) return\n\n      if (!provider_) {\n        const { default: SDK } = await import('@safe-global/safe-apps-sdk')\n        const sdk = new SDK(parameters)\n\n        // `getInfo` hangs when not used in Safe App iFrame\n        // https://github.com/safe-global/safe-apps-sdk/issues/263#issuecomment-1029835840\n        const safe = await withTimeout(() => sdk.safe.getInfo(), {\n          timeout: parameters.unstable_getInfoTimeout ?? 10,\n        })\n        if (!safe) throw new Error('Could not load Safe information')\n        const { SafeAppProvider } = await import(\n          '@safe-global/safe-apps-provider'\n        )\n        provider_ = new SafeAppProvider(safe, sdk)\n      }\n      return provider_\n    },\n    async getChainId() {\n      const provider = await this.getProvider()\n      if (!provider) throw new ProviderNotFoundError()\n      return Number(provider.chainId)\n    },\n    async isAuthorized() {\n      try {\n        const isDisconnected =\n          shimDisconnect &&\n          // If shim exists in storage, connector is disconnected\n          (await config.storage?.getItem('safe.disconnected'))\n        if (isDisconnected) return false\n\n        const accounts = await this.getAccounts()\n        return !!accounts.length\n      } catch {\n        return false\n      }\n    },\n    onAccountsChanged() {\n      // Not relevant for Safe because changing account requires app reload.\n    },\n    onChainChanged() {\n      // Not relevant for Safe because Safe smart contract wallets only exist on single chain.\n    },\n    onDisconnect() {\n      config.emitter.emit('disconnect')\n    },\n  }))\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}